---
title: Introducción a Prolog
---

<style>
.cursor {
    color: #E88D3E;
    font-weight: bold;
}
</style>

<script>
function toText(elem) {
  var bbox = elem.select("path")[0][0].getBBox();
  elem.selectAll("*").remove();
  return elem.append("text").text("X = ???").attr("x", bbox.x).attr("y", bbox.y + bbox.height);
}
</script>

## La sesión con el usuario

Un programa en Prolog se conforma de una serie de reglas. Pero antes de ver qué aspecto tiene veamos qué esperamos al ejecutarlo.

El usuario al usar un programa Prolog indicará un [goal u objetivo](#ref:g1_goal) del cual espera obtener soluciones en caso de que existan. La ejecución es la búsqueda de múltiples soluciones. Siempre.

<center id="g1">
  <%= embed_svg "goal-1.svg" %>
  <script>
    g1 = d3.select("#g1 svg");
    g1_goal = g1.selectAll("#shapePath1");
    g1_call = g1.selectAll("#shapePath11, #shapePath4");
    g1_exit = g1.selectAll("#shapePath12, #shapePath2");
    g1_redo = g1.selectAll("#shapePath13, #shapePath3");
    g1_fail = g1.selectAll("#shapePath14, #shapePath5");
  </script>
</center>

Al [iniciar la búsqueda](#ref:g1_call) se usarán las reglas definidas para obtener [una primera solución](#ref:g1_exit). A continuación el usuario podrá, luego de analizar la solución, [pedir otra](#ref:g1_redo). El programa mantiene un estado para seguir con la búsqueda. Suponiendo que exista una segunda solución, se informa [de la misma manera](#ref:g1_exit) y el se podrá [repetir](#ref:g1_redo) [el](#ref:g1_exit) [proceso](#ref:g1_redo). Eventualmente (si todo funciona bien) el programa indicará que [no hay más soluciones](#ref:g1_fail).

Ésta es la manera en la que el usuario interactura con un intérprete de Prolog. Veremos también que es una forma de entender cómo funciona un programa paso a paso.

## Un primer programa

El programa más simple sería una enumeración explícita de **hechos**.

<pre>
habla(juan, castellano).
habla(juan, inglés).
habla(maría, inglés).
habla(pedro, castellano).
</pre>

Una consulta estará formada por al menos una cláusula. En este caso hay una **variable sin instanciar** `X` y una **constante** `castellano`.

<pre>
?- habla(X, castellano).
</pre>

Es fácil ver que las soluciones posibles son aquellas donde `X=juan` y luego `X=pedro`.

Para obtenerlas, se recorren una por una las definiciones que coincidan, o **unifiquen** con `habla(X, castellano)`. Internamente se puede pensar en un cursor que recorre los hechos a medida que se van pidiendo soluciones.

En un [primer paso](javascript:g2s1()) se inicializa la consulta y el cursor se ubicará en la definición del primer hecho, que, como coincide con `habla(X, castellano)`, se **unifica** `X=juan` obteniendo la primer solución.

Luego el usuario podrá pedir una [segunda solución](javascript:g2s2()). A continuación se buscarán las siguientes definiciones que puedan unicar con `habla(X, castellano)`. Esto se logra recién en la última definición. Dando lugar al [segundo resultado](javascript:g2s3()) unificando ahora `X=pedro`. Notar que cada solución tiene una instanción distinta en las variables.

Al pedir una [tercera solución](javascript:g2s4()) no se encontrarán más definiciones que unifiquen con el objetivo y se informará que no hay más soluciones.

<center id="g2">
  <div style="float:left; text-align: left; font-size: 0.7em;">
    <code class="l1">habla(juan, castellano).</code><br/>
    <code class="l2">habla(juan, inglés).</code><br/>
    <code class="l3">habla(maría, inglés).</code><br/>
    <code class="l4">habla(pedro, castellano).</code><br/>
    <br/>
    <code class="l5">?- habla(X, castellano).<span class="n">↵</span></code><br/>
    <code class="l6">X = juan<span class="n">;↵</span></code><br/>
    <code class="l7">X = pedro<span class="n">;↵</span></code><br/>
    <code class="l8">fail</code><br/>
  </div>
  <%= embed_svg "program-single-goal.svg" %>
  <script>
    g2 = d3.select("#g2 svg");
    g2_goal = g2.selectAll("#shapePath1");
    g2_call = g2.selectAll("#shapePath10, #shapePath4, #shapePath18, #markerPath18");
    g2_result = toText(g2.select("#Shape20")).text("");
    g2_index = toText(g2.select("#Shape15")).text("?");
    g2_exit = g2.selectAll("#shapePath11, #shapePath2");
    g2_redo = g2.selectAll("#shapePath12, #shapePath3");
    g2_fail = g2.selectAll("#shapePath13, #shapePath5");
    g2_init_exit = g2.selectAll("#shapePath21, #shapePath23, #markerPath23");
    append(g2_init_exit, g2_exit);
    g2_redo_next = g2.selectAll("#shapePath19, #markerPath19");
    append(g2_redo_next, g2_redo);
    g2_next_exit = g2.selectAll("#shapePath22, #shapePath23, #markerPath23");
    append(g2_next_exit, g2_exit);
    g2_next_fail = g2.selectAll("#shapePath24, #shapePath26, #markerPath26");
    append(g2_next_fail, g2_fail);

    function append(target, source) {
      for(var i = 0; i < source[0].length; i++){
        target[0].push(source[0][i]);
      }
    }

    c2 = $("#g2");
    c2_consult_enter = $(".l5 .n", c2).hide();
    c2_result1 = $(".l6", c2).hide();
    c2_result1_enter = $(".l6 .n", c2).hide();
    c2_result2 = $(".l7", c2).hide();
    c2_result2_enter = $(".l7 .n", c2).hide();
    c2_fail = $(".l8", c2).hide();

    function setCursor(selector, context) {
      $("*", context).removeClass("cursor");
      $(selector, context).addClass("cursor");
    }

    function setG2CursorState(line) {
      g2_index.text(line);
      setCursor(".l" + line, c2);
    }

    function pause(callback) {
      if (callback) { window.setTimeout(callback, 500); }
    }

    function g2s1(callback) {
      highlight(g2_call, function(){
        setG2CursorState("1");
        highlight(g2_index, function(){
          highlight(g2_init_exit, function(){
            g2_result.text("X = juan");
            c2_result1.show();
            pause(callback);
          });
        });
      });
    }

    function g2s2(callback) {
      c2_result1_enter.show();
      pause(function(){
        g2_result.text("");
        highlight(g2_redo_next, function(){
          highlight(g2_index, function(){
            setG2CursorState("2");
            pause(function(){
              setG2CursorState("3");
              pause(function(){
                setG2CursorState("4");
                pause(callback)
              });
            });
          });
        });
      });
    }

    function g2s3(callback) {
      highlight(g2_next_exit, function(){
        g2_result.text("X = pedro");
        c2_result2.show();
        pause(callback);
      });
    }

    function g2s4() {
      c2_result2_enter.show();
      pause(function(){
        g2_result.text("");
        highlight(g2_redo_next, function(){
          highlight(g2_index, function(){
            g2_index.text("?");
            setCursor(".none", c2);

            pause(function(){
              highlight(g2_next_fail, function(){
                c2_fail.show();
              });
            });
          });
        });
      });
    }

    // $(function(){
    //   g2s1(function(){
    //     g2s2(function(){
    //       g2s3(g2s4);
    //     });
    //   });
    // });
  </script>
</center>

<p></p>

## Goals compuestos

```
?- habla(A, I), habla(B, I)
```

* soluciones sin sentido

```
?- habla(A, I), habla(B, I), A /= B.
```

* TBD solución con cajas



<script>
$(function(){

  $("a[href^='#ref']").each(function(){
    $(this).attr('href', "javascript:highlight(" + $(this).attr('href').substring(5) + ")")
  });

  // $("a[href^='javascript:highlight']").mouseenter(function(){
  //   eval($(this).attr('href'));
  // });
});

var animating = false;

function highlight(obj, callback) {
  if (animating) return;

  animating = true;
  original_color = obj.style("stroke");
  original_width = obj.style("stroke-width");

  duration = 1200;

  highlight_color = "#E88D3E";
  highlight_width = 4;
  obj.transition()
    .duration(duration / 4).style("stroke", highlight_color).style("stroke-width", highlight_width)
    .each("end", function(){
      obj.transition()
        .duration(duration / 4).style("stroke", original_color)
        .each("end", function(){
          obj.transition()
            .duration(duration / 4).style("stroke", highlight_color)
            .each("end", function(){
              obj.transition()
                .duration(duration / 4).style("stroke", original_color).style("stroke-width", original_width)
                .each("end", function(){
                  animating = false;
                  if (callback) { callback(); }
                });
            });
        });
    });
}
</script>

--

## Referencias

* [http://www.amzi.com/AdventureInProlog](http://www.amzi.com/AdventureInProlog)
